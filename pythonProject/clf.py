import traja
from traja import TrajaCollection
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import ShuffleSplit
from sktime.transformations.panel.compose import ColumnConcatenator
from sklearn.pipeline import Pipeline
from sktime.classification.interval_based import TimeSeriesForestClassifier
from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import cross_validate
from sktime.classification.dictionary_based import BOSSEnsemble
from sktime.classification.compose import ColumnEnsembleClassifier
from sklearn.model_selection import train_test_split


def generate_np_data(num_short, num_long):
    x_short_nps = []
    y_short_nps = []
    short_trjs = {ind: traja.generate(n=1000, random=True, step_length=2, seed=ind) for ind in range(num_short)}
    for trj in short_trjs:
        derivs = traja.get_derivatives(short_trjs[trj])
        ang = traja.calc_angle(short_trjs[trj])
        short_trjs[trj] = short_trjs[trj].join(derivs).join(ang.rename('angles'))
        short_trjs[trj].drop(['displacement_time', 'speed_times', 'acceleration_times'], inplace=True, axis=1)
        short_trjs[trj].to_numpy
        x_short_nps.append(short_trjs[trj])
        y_short_nps.append(0)

        x_short_data = np.dstack(x_short_nps)

    x_long_nps = [x_short_data]
    long_trjs = {ind: traja.generate(n=1000, random=True,step_length= 5, seed=ind+num_short) for ind in range(num_long)}
    for trj in long_trjs:
        derivs = traja.get_derivatives(long_trjs[trj])
        ang = traja.calc_angle(long_trjs[trj])
        long_trjs[trj] = long_trjs[trj].join(derivs).join(ang.rename('angles'))
        long_trjs[trj].drop(['displacement_time', 'speed_times', 'acceleration_times'], inplace=True, axis=1)
        long_trjs[trj].to_numpy
        x_long_nps.append(long_trjs[trj])
        y_short_nps.append(1)

    X = np.dstack(x_long_nps)
    X = np.transpose(X)
    Y = np.array(y_short_nps)
    return X,Y

import random
from random import choice
def generate_data_more(stepLengths, numTraj):
    x_nps = []
    y_nps = []
    for i in range(numTraj):
        s = choice(stepLengths)
        traj = traja.generate(n=1000, random=True, step_length=s, seed=i)
        derivs = traja.get_derivatives(traj)
        ang = traja.calc_angle(traj)
        traj = traj.join(derivs).join(ang.rename('angles'))
        traj.drop(['displacement_time', 'speed_times', 'acceleration_times'], inplace=True, axis=1)
        traj.to_numpy
        x_nps.append(traj)
        y_nps.append(s)

    X = np.dstack(x_nps)
    X = np.transpose(X)
    Y = np.array(y_nps)
    return X,Y



def split_data(X, Y):
# shuffle + split data set into training and testing set
    all_indices = list(range(X.shape[0]))
    train_ind, test_ind = train_test_split(all_indices, test_size=0.1)
    X_train = X[train_ind, :, 2:]
    X_test = X[test_ind, :, 2:]
    Y_train = Y[train_ind]
    Y_test = Y[test_ind]
    return (X_train, Y_train, X_test, Y_test)


def ColEnsemble(X_train, Y_train, X_test, Y_test):
    # This estimator allows different columns or column subsets of the input to be transformed separately and the
    # features generated by each transformer will be ensembled to form a single output.
    clf = ColumnEnsembleClassifier(
        estimators=[
            ("TSF0", TimeSeriesForestClassifier(n_estimators=4), [0]),
            ("TSF1", TimeSeriesForestClassifier(n_estimators=4), [1]),
            ("TSF2", TimeSeriesForestClassifier(n_estimators=4), [2]),
            ("TSF3", TimeSeriesForestClassifier(n_estimators=4), [3]),
            ("TSF4", TimeSeriesForestClassifier(n_estimators=4), [4]),
            ("TSF5", TimeSeriesForestClassifier(n_estimators=4), [5]),
            ("TSF6", TimeSeriesForestClassifier(n_estimators=4), [6])
        ]
    )
    clf.fit(X_train, Y_train)
    score = clf.score(X_test, Y_test)
    return score

def concatenation(X_train, Y_train, X_test, Y_test):
    steps = [
        ("concatenate", ColumnConcatenator()),
        ("classify", TimeSeriesForestClassifier(n_estimators=10)),
    ]
    clf = Pipeline(steps)
    clf.fit(X_train, Y_train)
    score = clf.score(X_test, Y_test)
    return score





X, Y = generate_np_data(50, 50)
X_train, Y_train, X_test, Y_test = split_data(X, Y)
print(X_train.shape)
print(concatenation(X_train, Y_train, X_test, Y_test))
print(ColEnsemble(X_train, Y_train, X_test, Y_test))

X, Y = generate_data_more(range(1, 101), 100)
X_train, Y_train, X_test, Y_test = split_data(X, Y)
print(concatenation(X_train, Y_train, X_test, Y_test))
print(ColEnsemble(X_train, Y_train, X_test, Y_test))




